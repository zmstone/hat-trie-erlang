%% This test module uses proper to generate test data and operations,
%% perfrom the same operations against both ETS and trie,
%% then expect the same state.

-module(hattrie_segs_prop_tests).

-define(EUNIT_NOAUTO, true).
-include_lib("proper/include/proper.hrl").
-include_lib("eunit/include/eunit.hrl").

prop_check_test_() ->
  {timeout, 60,
   fun prop_check_run/0
  }.

prop_check_run() ->
  Opts = [{numtests, 1000}, {to_file, user}],
  ?assert(
     proper:quickcheck(
       ?FORALL(Ops, prop_ops(), prop_check(Ops)),
       Opts)
  ).

prop_op() -> proper_types:oneof([lookup, delete]).
prop_segs() ->
  proper_types:non_empty(proper_types:list(proper_types:binary(100))).
prop_value() -> proper_types:binary(64). %% trie value
prop_ops() -> proper_types:list({prop_op(), prop_segs(), prop_value()}).

prop_check(Ops) ->
  Name = trie_test,
  Ets = ets:new(Name, [set]),
  ok = hattrie:create(Name),
  hattrie:clear_segs(),
  try
    ok =:= do_prop_check(Ets, Name, Ops)
  after
    ets:delete(Ets),
    hattrie:destroy(Name),
    hattrie:clear_segs()
  end.

do_prop_check(Ets, Trie, []) ->
  All = ets:tab2list(Ets),
  lists:foreach(
    fun({K, V}) -> ?assertEqual([V], hattrie:lookup_segs(Trie, K)) end, All);
do_prop_check(Ets, Trie, [{Op, Segs0, V} | Ops]) ->
  Segs = lists:map(fun fix_segs/1, Segs0),
  ets:insert(Ets, {Segs, V}),
  hattrie:upsert_segs(Trie, Segs, V),
  case Op of
    lookup ->
      ?assertEqual([V], hattrie:lookup_segs(Trie, Segs));
    delete ->
      ets:delete(Ets, Segs),
      ?assertEqual(ok, hattrie:delete_segs(Trie, Segs))
  end,
  do_prop_check(Ets, Trie, Ops).

%% should not allow 0 in the generated bytes
fix_segs(Bin) ->
  Fix = fun(<<0>>) -> <<1>>;
           (X)     -> X
        end,
  iolist_to_binary([ Fix(X) || <<X>> <= Bin ]).
